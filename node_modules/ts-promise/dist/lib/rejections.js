"use strict";
/**
 * Definitely- and possibly-unhandled rejection handling.
 *
 * Copyright (C) 2017 Martin Poelstra
 * License: MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseError_1 = require("./BaseError");
var util_1 = require("./util");
/**
 * Base class for errors thrown when a (possibly) rejected promise is detected.
 */
var BaseUnhandledRejection = /** @class */ (function (_super) {
    __extends(BaseUnhandledRejection, _super);
    function BaseUnhandledRejection(name, message, reason) {
        var _this = _super.call(this, name, message + ": " + reason) /* istanbul ignore next (TS emitted code) */ || this;
        _this.reason = reason;
        // In case we have a reason, and it has a stack: use it instead of our
        // own stack, as it's more helpful to see where the original error was
        // thrown, than where it was thrown inside the promise lib.
        // In case we don't have a stack, explicitly state so, to not let people
        // chase a problem in the promise lib that isn't there...
        var stack = _this.reason && typeof _this.reason === "object" && _this.reason.stack;
        if (typeof stack !== "string") {
            stack = String(_this.reason);
        }
        _this.stack = _this.name + ": " + stack;
        return _this;
    }
    return BaseUnhandledRejection;
}(BaseError_1.default));
exports.BaseUnhandledRejection = BaseUnhandledRejection;
/**
 * Thrown when a rejected promise is explicitly terminated with `.done()`.
 */
var UnhandledRejection = /** @class */ (function (_super) {
    __extends(UnhandledRejection, _super);
    function UnhandledRejection(reason, trace) {
        var _this = _super.call(this, "UnhandledRejection", "unhandled rejection", reason) /* istanbul ignore next (TS emitted code) */ || this;
        // TODO: Find a better way to merge the location of `.done()` in the
        // trace, because nobody will look for this property...
        _this.trace = trace;
        return _this;
    }
    return UnhandledRejection;
}(BaseUnhandledRejection));
exports.UnhandledRejection = UnhandledRejection;
/**
 * Emitted when a rejected promise isn't handled.
 * @see Promise.onPossiblyUnhandledRejection
 */
var PossiblyUnhandledRejection = /** @class */ (function (_super) {
    __extends(PossiblyUnhandledRejection, _super);
    function PossiblyUnhandledRejection(promise) {
        var _this = _super.call(this, "PossiblyUnhandledRejection", "possibly unhandled rejection", promise.reason()) /* istanbul ignore next (TS emitted code) */ || this;
        _this.promise = promise;
        return _this;
    }
    return PossiblyUnhandledRejection;
}(BaseUnhandledRejection));
exports.PossiblyUnhandledRejection = PossiblyUnhandledRejection;
/**
 * Emit PromiseRejectionEvent (in browser environment).
 * Dispatches the event to all registered handlers, e.g.
 * - window.onunhandledrejection / window.onrejectionhandled
 * - window.addEventListener("unhandledrejection", (event) => { ... }), etc
 * Uses self in case of WebWorker.
 *
 * @param type Either "unhandledrejection" or "rejectionhandled"
 * @param reason Value used to reject promise
 * @param promise ts-promise instance
 * @return true when event was 'handled' (i.e. someone called preventDefault() on it), false otherwise
 */
function emitRejectionEvent(type, reason, promise) {
    // Browsers do a native Promise.resolve() on the promise given in PromiseRejectEvent,
    // which causes an unhandled rejection error due to that native promise not being handled,
    // and prevents the user's unhandled rejection handler from accessing the actual
    // ts-promise Promise. This would make the handled rejection handler useless, because that
    // gets another native promise.
    // So, prevent the unhandled rejection when constructing the event, then override the
    // property to return the 'real' promise.
    // MDN says it isn't cancelable, but both Chrome and Firefox do have it cancelable.
    var event = new PromiseRejectionEvent(type, {
        cancelable: true,
        promise: true,
        reason: reason,
    });
    Object.defineProperty(event, "promise", {
        value: promise,
    });
    var global = util_1.getGlobal();
    if (global.dispatchEvent && !global.dispatchEvent(event)) {
        // Someone called preventDefault()
        return true;
    }
    return false;
}
/**
 * Default handler for an`UnhandledRejection` error, which contains the
 * original reason of the rejection.
 * In Node, if you don't have an `unhandledException` event handler, that will cause your
 * program to terminate after printing the error.
 * When overriding the default handler, it is recommended to keep a similar behavior,
 * as your program is likely in an unknown state.
 */
function defaultUnhandledRejectionHandler(reason, doneTrace) {
    var unhandledRejection = new UnhandledRejection(reason, doneTrace);
    // Leave the comment after the throw: may show up in source line in node
    throw unhandledRejection; // Unhandled rejection caught by .done()
}
exports.defaultUnhandledRejectionHandler = defaultUnhandledRejectionHandler;
/**
 * Default handler for possibly unhandled rejection. It will:
 * - emit Node's `unhandledRejection` event if present, or
 * - emit an `unhandledrejection` (note small R) `PromiseRejectionEvent` on `window` or `self` if present, or
 * - log the rejection using `console.warn()`.
 *
 * Note: when attaching an `unhandledrejection` handler in the browser, make sure to
 * call `event.preventDefault()` to prevent ts-promise's default fallback logging.
 */
function defaultPossiblyUnhandledRejectionHandler(promise) {
    var log = true;
    // First try to emit Node event
    if (typeof process !== "undefined" && typeof process.emit === "function") {
        if (process.emit("unhandledRejection", promise.reason(), promise)) {
            // A handler was called
            log = false;
        }
    }
    else if (typeof PromiseRejectionEvent === "function") {
        // Then fire a browser event if supported by the browser
        if (emitRejectionEvent("unhandledrejection", promise.reason(), promise)) {
            log = false;
        }
    }
    // Fallback to log to console
    if (log) {
        var possiblyUnhandledRejection = new PossiblyUnhandledRejection(promise);
        // tslint:disable-next-line:no-console
        console.warn(possiblyUnhandledRejection.stack);
    }
}
exports.defaultPossiblyUnhandledRejectionHandler = defaultPossiblyUnhandledRejectionHandler;
/**
 * Default handler for handled rejections.
 * It will emit Node's `rejectionHandled` event if present, or emit a
 * `rejectionhandled` (note small R) event on `window` (or `self`) if present.
 */
function defaultPossiblyUnhandledRejectionHandledHandler(promise) {
    // First try to emit Node event
    if (typeof process !== "undefined" && typeof process.emit === "function") {
        process.emit("rejectionHandled", promise);
    }
    else if (typeof PromiseRejectionEvent === "function") {
        // Then fire a browser event if supported by the browser
        emitRejectionEvent("rejectionhandled", promise.reason(), promise);
    }
}
exports.defaultPossiblyUnhandledRejectionHandledHandler = defaultPossiblyUnhandledRejectionHandledHandler;
//# sourceMappingURL=rejections.js.map