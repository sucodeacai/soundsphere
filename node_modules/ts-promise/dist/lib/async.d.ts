/**
 * Call queue for executing callbacks asynchronously.
 *
 * Prevents releasing Zalgo.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
export declare class Async {
    private _pool;
    private _mainRing;
    private _idleRing;
    private _flushing;
    private _scheduled;
    private _scheduler?;
    /**
     * Configure alternative scheduler to use.
     * The scheduler function will be called with a flusher, which needs to be
     * executed to flush the queue. Note: the flusher may throw an
     * exception, if any of the callbacks on the queue throws one.
     * This will result in another flush to be scheduled before returning.
     *
     * Call with `undefined` to reset the scheduler to the default (setImmediate).
     *
     * Example usage (this is basically the default):
     *   setScheduler((flusher) => setImmediate(flusher));
     * Note: this is slightly different from just setScheduler(setImmediate), in that
     * the former allows overriding setImmediate in e.g. unit tests.
     */
    setScheduler(scheduler: ((flusher: () => void) => void) | undefined): void;
    /**
     * Enqueue callback to be executed as soon as possible, but outside of the
     * current stackframe. It is OK to enqueue new callbacks while they are
     * being executed, in which case they will all be called before handing
     * back control to the host JS environment.
     *
     * @param callback Callback to be executed with given argument
     * @param arg      Argument to pass to callback
     */
    enqueue(callback: () => void): void;
    enqueue<T>(callback: (arg: T) => void, arg: T): void;
    /**
     * Enqueue callback to be executed after all other enqueued callbacks have
     * been executed.
     * Once the idle callbacks start to be executed, that 'batch' of idle callbacks
     * will all be executed before any newly enqueued callbacks will be executed.
     *
     * @param callback Callback to be executed with given argument
     * @param arg      Argument to pass to callback
     */
    enqueueIdle(callback: () => void): void;
    enqueueIdle<T>(callback: (arg: T) => void, arg: T): void;
    /**
     * Flush callback queues.
     * First, the 'normal' callback queues are flushed until they are empty (i.e.
     * new callbacks that are added while executing will also be processed).
     * Then, the 'idle' queues are flushed (also until they are empty).
     * Flushing repeats until no more items are enqueued in normal or idle queues.
     * It is an error to call flush from within an enqueued callback.
     */
    flush(): void;
    private _flusher;
    private _schedule;
    private _scheduledFlush;
}
export declare let async: Async;
export default async;
