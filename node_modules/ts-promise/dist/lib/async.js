"use strict";
/**
 * Call queue for executing callbacks asynchronously.
 *
 * Prevents releasing Zalgo.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var CallQueue = /** @class */ (function () {
    function CallQueue() {
        this.length = 0;
        // Basically twice the number of simultaneously resolving promises
        this._max = 1000;
        this._first = 0;
    }
    /**
     * Push a new callback to the queue.
     * @return true when the queue still has space, false if it's now 'full'
     */
    CallQueue.prototype.push = function (callback, arg) {
        this[this.length++] = callback;
        this[this.length++] = arg;
        return this.length < this._max;
    };
    /**
     * Flush all callbacks in this queue.
     * Note that it is 'ok' for callbacks to throw an error;
     * the next call to flush() will flush the remainder of the queue.
     * When this function returns, the queue will be 'reset' to its beginning.
     */
    CallQueue.prototype.flush = function () {
        while (this._first < this.length) {
            var callback = this[this._first];
            var arg = this[this._first + 1];
            this[this._first] = this[this._first + 1] = undefined;
            this._first += 2;
            callback(arg);
        }
        this.length = 0;
        this._first = 0;
    };
    CallQueue.prototype.empty = function () {
        return this._first === this.length;
    };
    return CallQueue;
}());
var Ring = /** @class */ (function () {
    function Ring(pool) {
        /**
         * Ring of queues.
         * Guaranteed to always contain at least one queue.
         */
        this._ring = [new CallQueue()];
        /**
         * Queue to put new callbacks in, i.e. the last queue in the ring.
         * If `undefined`, a new queue will be obtained and added to ring on next enqueue.
         */
        this._current = this._ring[0];
        this._pool = pool;
    }
    Ring.prototype.enqueue = function (callback, arg) {
        // Make sure this._current points to a queue: obtain one
        // from pool or create a new one if necessary.
        if (!this._current) {
            this._current = this._pool.pop();
            if (!this._current) {
                this._current = new CallQueue();
            }
            this._ring.push(this._current);
        }
        // Add callback to queue
        if (!this._current.push(callback, arg)) {
            // Queue full, load a new one next time
            this._current = undefined;
        }
    };
    /**
     * Call all callbacks in all queues in this ring, until it is empty.
     * Note: it is 'OK' for a callback to throw an error; ring/queue state
     * will remain valid and remaining items will be flushed on next call
     * to `flush()`.
     */
    Ring.prototype.flush = function () {
        while (true) {
            // Ring is guaranteed to have at least one queue (even though
            // queue might be empty when flush() is e.g. called manually).
            this._ring[0].flush();
            // If this is the last queue in the ring, we're done
            if (this._ring.length === 1) {
                break;
            }
            // Shift the now empty ring into pool.
            // Queue at index 0 is empty, and ring length >= 2.
            // So, this._current is guaranteed to point to something 'later'
            // than queue at index 0, and we can safely move index 0 to the
            // pool.
            this._pool.push(this._ring.shift());
        }
        // Ring is now guaranteed to contain only a single, empty queue, so we
        // could move it to the pool.
        // However, because it's the last item remaining, better to simply
        // leave it in the ring, saves unnecessary re-move on next enqueue.
        // Also, make sure that new items will be loaded into that queue.
        this._current = this._ring[0];
    };
    /**
     * Return true if no callbacks are enqueued in this ring.
     */
    Ring.prototype.empty = function () {
        return this._ring.length === 1 && this._ring[0].empty();
    };
    return Ring;
}());
function defaultScheduler(callback) {
    // Note: we explicitly re-check types and call it here (instead of
    // e.g. assigning it to a variable once at startup), to allow
    // setImmediate / setTimeout to be replaced by mocked ones
    // (e.g. Sinon's useFakeTimers())
    if (typeof setImmediate === "function") {
        setImmediate(callback);
    }
    else {
        setTimeout(callback, 0);
    }
}
var Async = /** @class */ (function () {
    function Async() {
        var _this = this;
        this._pool = [];
        this._mainRing = new Ring(this._pool);
        this._idleRing = new Ring(this._pool);
        this._flushing = false;
        this._scheduled = false;
        this._scheduler = undefined;
        this._flusher = function () { return _this._scheduledFlush(); };
    }
    /**
     * Configure alternative scheduler to use.
     * The scheduler function will be called with a flusher, which needs to be
     * executed to flush the queue. Note: the flusher may throw an
     * exception, if any of the callbacks on the queue throws one.
     * This will result in another flush to be scheduled before returning.
     *
     * Call with `undefined` to reset the scheduler to the default (setImmediate).
     *
     * Example usage (this is basically the default):
     *   setScheduler((flusher) => setImmediate(flusher));
     * Note: this is slightly different from just setScheduler(setImmediate), in that
     * the former allows overriding setImmediate in e.g. unit tests.
     */
    Async.prototype.setScheduler = function (scheduler) {
        /* tslint:disable:no-null-keyword */ // 'old' API told you to use `null` instead of `undefined`
        util_1.assert(scheduler === undefined || scheduler === null || typeof scheduler === "function");
        /* tslint:enable:no-null-keyword */
        this._scheduler = scheduler;
    };
    Async.prototype.enqueue = function (callback, arg) {
        if (!this._flushing && !this._scheduled) {
            this._schedule();
        }
        this._mainRing.enqueue(callback, arg);
    };
    Async.prototype.enqueueIdle = function (callback, arg) {
        if (!this._flushing && !this._scheduled) {
            this._schedule();
        }
        this._idleRing.enqueue(callback, arg);
    };
    /**
     * Flush callback queues.
     * First, the 'normal' callback queues are flushed until they are empty (i.e.
     * new callbacks that are added while executing will also be processed).
     * Then, the 'idle' queues are flushed (also until they are empty).
     * Flushing repeats until no more items are enqueued in normal or idle queues.
     * It is an error to call flush from within an enqueued callback.
     */
    Async.prototype.flush = function () {
        util_1.assert(!this._flushing, "cannot recursively flush");
        this._flushing = true;
        try {
            while (true) {
                this._mainRing.flush();
                if (this._idleRing.empty()) {
                    // Both rings now empty: done
                    break;
                }
                // Main ring empty, idle ring not empty.
                // Start flushing idle ring, making sure it is completely
                // processed before processing new 'normal' callbacks (even
                // if it is interrupted by a thrown error in one of them).
                // Also, make sure that any new normal callbacks are going
                // to be processed before any new idle callbacks.
                var emptyRing = this._mainRing;
                this._mainRing = this._idleRing;
                this._idleRing = emptyRing;
            }
        }
        finally {
            this._flushing = false;
            // If one of the callbacks in the queue throws an exception,
            // (e.g. when Promise#done() detects a rejection) make sure to
            // reschedule the remainder of the queue(s) for another iteration.
            // This approach has the advantage of immediately allowing to stop
            // the program in e.g. NodeJS, but also allows to continue running
            // correctly in a browser.
            // Note: we may be called explicitly, even though we were also
            // already scheduled, before.
            if ((!this._mainRing.empty() || !this._idleRing.empty()) && !this._scheduled) {
                this._schedule();
            }
        }
    };
    Async.prototype._schedule = function () {
        util_1.assert(!this._scheduled);
        var scheduler = this._scheduler || defaultScheduler;
        // Call scheduler without a `this`
        scheduler(this._flusher);
        this._scheduled = true;
    };
    Async.prototype._scheduledFlush = function () {
        // Indicate that this 'iteration' of the flush is complete.
        this._scheduled = false;
        this.flush();
    };
    return Async;
}());
exports.Async = Async;
exports.async = new Async();
exports.default = exports.async;
//# sourceMappingURL=async.js.map