(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.tsPromise = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
/**
 * Base class for custom errors.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Base class for custom errors, which preserves stack and
 * has correct prototype chain.
 */
var BaseError = /** @class */ (function (_super) {
    __extends(BaseError, _super);
    function BaseError(name, message) {
        var _newTarget = this.constructor;
        var _this = 
        /* istanbul ignore next: internal TypeScript code */
        _super.call(this, message) || this;
        var fixStack = false;
        // This fixes the prototype chain if it's broken (when emitting for ES 5 or lower)
        /* istanbul ignore else: only run tests with ES5 emit for now */
        if (_this.constructor !== _newTarget) {
            // Object.setPrototypeOf is IE>=11 and ES6
            /* istanbul ignore else: only run tests on Node for now */
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(_this, _newTarget.prototype);
            }
            fixStack = true;
        }
        // This occurs when the error is not thrown but only created in IE
        /* istanbul ignore if: only run tests on Node for now */
        if (!("stack" in _this)) {
            fixStack = true;
        }
        _this.name = name;
        /* istanbul ignore else: only run tests on Node for now */
        if (fixStack) {
            // This.name and this.message must be set correctly in order to fix the stack correctly
            /* istanbul ignore else: only run tests on Node for now */
            if (Error.captureStackTrace) {
                Error.captureStackTrace(_this, _newTarget);
            }
            else {
                var error = new Error(message);
                error.name = name;
                try {
                    throw error;
                }
                catch (error) {
                    _this.stack = error.stack || String(error);
                }
            }
        }
        return _this;
    }
    return BaseError;
}(Error));
exports.default = BaseError;

},{}],2:[function(require,module,exports){
"use strict";
/**
 * Promise implementation in TypeScript.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-unused-expression */ // prevent errors on `trace && trace(....)`
/* tslint:disable:no-bitwise */ // for flags
var async_1 = require("./async");
var rejections_1 = require("./rejections");
var Trace_1 = require("./Trace");
var util_1 = require("./util");
var trace;
var longTraces = false;
var State;
(function (State) {
    State[State["Pending"] = 0] = "Pending";
    State[State["Fulfilled"] = 1] = "Fulfilled";
    State[State["Rejected"] = 2] = "Rejected";
})(State || (State = {}));
/**
 * Bit flags about a Promise's internal state.
 */
var Flags;
(function (Flags) {
    Flags[Flags["RejectionHandled"] = 1] = "RejectionHandled";
    Flags[Flags["UnhandledRejectionNotified"] = 2] = "UnhandledRejectionNotified";
})(Flags || (Flags = {}));
function internalResolver(fulfill, reject) {
    /* no-op, sentinel value */
}
internalResolver(undefined, undefined); // just for code coverage...
function noop() {
    /* no-op */
}
var getThenError = {
    error: undefined,
};
function wrapNonError(a) {
    // This is basically a marker for the places where we need to check
    // handling of errors for .error() support.
    // A no-op for now.
    return a;
}
var dummyDoneTrace = new Trace_1.default();
/**
 * Currently unwrapping promise, while running one of its then-callbacks.
 * Used to set the source of newly created promises.
 * We guarantee that at most one callback of a then() is running at any time.
 */
var unwrappingPromise;
var promiseIdCounter = 0;
/**
 * Fast, robust, type-safe promise implementation.
 */
var Promise = /** @class */ (function () {
    /**
     * Create new Promise.
     *
     * Pass a callback that will receive a `resolve()` and `reject()` function
     * to seal the promise's fate.
     *
     * @param  resolver Called with resolve and reject functions
     */
    function Promise(resolver) {
        var _this = this;
        this._id = promiseIdCounter++;
        this._state = 0 /* Pending */;
        this._result = undefined; // Can be fulfillment value or rejection reason
        this._handlers = undefined;
        this._flags = 0;
        this._trace = undefined;
        trace && trace(this, "construct");
        if (longTraces) {
            this._trace = new Trace_1.default(Promise);
            if (unwrappingPromise) {
                this._setSource(unwrappingPromise);
            }
        }
        if (resolver === internalResolver) {
            // Internally created promises pass 'internalResolver', signalling
            // that resolving will be done by calling private methods on the
            // Promise. This saves having to create 2 closures.
            return;
        }
        if (typeof resolver !== "function") {
            throw new TypeError("Promise resolver is not a function");
        }
        var called = false;
        try {
            resolver(function (y) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,
                // run `[[Resolve]](promise, y)`
                called = true;
                _this._resolve(y);
            }, function (r) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,
                // reject `promise` with `r`
                called = true;
                _this._reject(wrapNonError(r));
            });
        }
        catch (e) {
            // 2.3.3.3.4: If calling `then` throws an exception `e`,
            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.
            if (!called) {
                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.
                called = true;
                this._reject(wrapNonError(e));
            }
        }
    }
    /**
     * Run either `onFulfilled` or `onRejected` callbacks when the promise is
     * resolved. Returns another promise for the return value of such a
     * callback.
     *
     * The callback will always be called at most once, and always
     * asynchronously (i.e. some time after e.g. the `resolver` passed to the
     * constructor has resolved the promise).
     *
     * Any error thrown or rejected promise returned from a callback will cause
     * the returned promise to be rejected with that error.
     *
     * If either or both callbacks are missing, the fulfillment or rejection is
     * passed on unmodified.
     *
     * Use `.catch(onRejected)` instead of `.then(undefined, onRejected)` for
     * stronger typing, better readability, and more functionality (predicates).
     *
     * @param onFulfilled Callback called with promise's fulfillment
     *                    value iff promise is fulfilled. Callback can return
     *                    another value or promise for a value.
     * @param onRejected  Optional callback called with promise's rejection
     *                    reason iff promise is rejected. Callback can return
     *                    another value or promise for a value.
     * @return Promise for value returned by either of the callbacks
     */
    Promise.prototype.then = function (onFulfilled, onRejected) {
        trace && trace(this, "then(" + typeof onFulfilled + ", " + typeof onRejected + ")");
        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== "function" ||
            this._state === 2 /* Rejected */ && typeof onRejected !== "function") {
            // Optimization: handler is short-circuited, so pass the result (value/rejection)
            // through unmodified.
            // The typecast is safe, because we either have a fulfillment value
            // but no handler that could change the type, or a rejection without a
            // handler that could change it, so R === T in this case.
            // TODO: verify whether longTraces etc still work as expected
            return this;
        }
        // Construct new Promise, but use subclassed constructor, if any
        var slave = new (Object.getPrototypeOf(this).constructor)(internalResolver);
        slave._setSource(this);
        this._enqueue(onFulfilled, onRejected, slave, undefined);
        return slave;
    };
    /**
     * Run either `onFulfilled` or `onRejected` callbacks when the promise is
     * resolved. If the callback throws an error or the returned value resolves
     * to a rejection, the library will (asynchronously) throw an
     * `UnhandledRejectionError` with that error.
     *
     * The callback will always be called at most once, and always
     * asynchronously (i.e. some time after e.g. the `resolver` passed to the
     * constructor has resolved the promise).
     *
     * @param onFulfilled Optional callback called with promise's fulfillment
     *                    value iff promise is fulfilled. Any error thrown or
     *                    rejection returned will cause an UnhandledRejectionError
     *                    to be thrown.
     * @param onRejected  Optional callback called with promise's rejection
     *                    reason iff promise is rejected. Any error thrown or
     *                    rejection returned will cause an UnhandledRejectionError
     *                    to be thrown.
     */
    Promise.prototype.done = function (onFulfilled, onRejected) {
        trace && trace(this, "done(" + typeof onFulfilled + ", " + typeof onRejected + ")");
        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== "function") {
            return;
        }
        var doneTrace = dummyDoneTrace;
        if (longTraces) {
            doneTrace = new Trace_1.default();
            if (this._trace) {
                doneTrace.setSource(this._trace);
            }
        }
        this._enqueue(onFulfilled, onRejected, undefined, doneTrace);
    };
    /**
     * Catch only errors that match predicate in case promise is rejected.
     * Predicate can be an Error (sub-)class, array of Error classes, or a
     * function that can return true to indicate a match.
     *
     * The returned promise is resolved with the output of the callback, so it
     * is possible to re-throw the error, but also to return a 'replacement'
     * value that should be used instead.
     *
     * @param predicate   Optional Error class, array of Error classes or match
     *                    function
     * @param onRejected  Callback called with promise's rejection reason iff
     *                    promise is rejected. Callback can return another value
     *                    or promise for a value.
     * @return Promise for original value, or 'replaced' value in case of error
     */
    Promise.prototype.catch = function () {
        if (arguments.length === 1) {
            var onRejected = arguments[0];
            return this.then(undefined, onRejected);
        }
        else {
            var predicate_1 = arguments[0];
            var onRejected_1 = arguments[1];
            return this.then(undefined, function (reason) {
                var match = false;
                if (typeof predicate_1 === "function") {
                    if (predicate_1.prototype instanceof Error || predicate_1 === Error) {
                        match = reason instanceof predicate_1;
                    }
                    else {
                        match = predicate_1(reason);
                    }
                }
                else if (Array.isArray(predicate_1)) {
                    for (var _i = 0, predicate_2 = predicate_1; _i < predicate_2.length; _i++) {
                        var p = predicate_2[_i];
                        if (reason instanceof p) {
                            match = true;
                            break;
                        }
                    }
                }
                else {
                    throw new TypeError("invalid predicate to .catch(), got " + typeof predicate_1);
                }
                if (match) {
                    return onRejected_1(reason);
                }
                return Promise.reject(reason);
            });
        }
    };
    /**
     * Asynchronous equivalent of try { } finally { }.
     *
     * Runs `handler` when promise resolves (fulfilled or rejected).
     * Handler is passed the current promise (which is guaranteed to be
     * resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,
     * etc.
     *
     * When `handler` returns `undefined` or its promise is fulfilled, the
     * promise from `finally()` is resolved to the original promise's resolved
     * value or rejection reason.
     * If `handler` throws an error or returns a rejection, the result of
     * `finally()` will be rejected with that error.
     *
     * Example:
     * someLenghtyOperation().finally((result) => {
     *   if (result.isFulfilled()) {
     *     console.log("succeeded");
     *   } else {
     *     console.log("failed", result.reason());
     *   }
     * });
     *
     * @param  handler Callback called with promise when it is resolved.
     * @return promise with same value/reason as this one, after `handler`'s
     *         result (if any) has been fulfilled, or a promise rejected with
     *         `handler`'s error if it threw one or returned a rejection.
     */
    Promise.prototype.finally = function (handler) {
        var _this = this;
        var runner = function () { return handler(_this); };
        return this.then(runner, runner).return(this);
    };
    /**
     * Return `true` when promise is fulfilled, `false` otherwise.
     *
     * @return `true` when promise is fulfilled, `false` otherwise.
     */
    Promise.prototype.isFulfilled = function () {
        return this._state === 1 /* Fulfilled */;
    };
    /**
     * Return `true` when promise is rejected, `false` otherwise.
     *
     * Note: this does not consider the rejection to be 'handled', if
     * it is rejected.
     *
     * @return `true` when promise is rejected, `false` otherwise.
     */
    Promise.prototype.isRejected = function () {
        return this._state === 2 /* Rejected */;
    };
    /**
     * Return `true` when promise is pending (may be resolved to another pending
     * promise), `false` otherwise.
     *
     * @return `true` when promise is pending (may be resolved to another pending
     *         promise), `false` otherwise.
     */
    Promise.prototype.isPending = function () {
        return this._state === 0 /* Pending */;
    };
    /**
     * Return fulfillment value if fulfilled, otherwise throws an error.
     *
     * @return Fulfillment value if fulfilled, otherwise throws an error.
     */
    Promise.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new Error("Promise is not fulfilled");
        }
        return this._result;
    };
    /**
     * Return rejection value if rejected, otherwise throws an error.
     *
     * Note: this does not consider the rejection to be 'handled', if
     * it is rejected. To do so, explicitly call e.g.
     * `.suppressUnhandledRejections()`.
     *
     * @return Rejection value if rejected, otherwise throws an error.
     */
    Promise.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new Error("Promise is not rejected");
        }
        return this._result;
    };
    /**
     * Prevent this promise from throwing a PossiblyUnhandledRejection in
     * case it becomes rejected. Useful when the rejection will be handled later
     * (i.e. after the current 'tick'), or when the rejection is to be ignored
     * completely.
     *
     * This is equivalent to calling `.catch(() => {})`, but more efficient.
     *
     * Note: any derived promise (e.g. by calling `.then(cb)`) causes a new
     * promise to be created, which can still cause the rejection to be thrown.
     *
     * Note: if the rejection was already notified, the rejection-handled handler
     * will be called.
     */
    Promise.prototype.suppressUnhandledRejections = function () {
        this._setRejectionHandled();
    };
    /**
     * @return A human-readable representation of the promise and its status.
     */
    Promise.prototype.inspect = function () {
        return this.toString();
    };
    /**
     * @return A human-readable representation of the promise and its status.
     */
    Promise.prototype.toString = function () {
        var state;
        switch (this._state) {
            case 0 /* Pending */:
                state = "pending";
                break;
            case 1 /* Fulfilled */:
                state = "fulfilled";
                break;
            case 2 /* Rejected */:
                state = "rejected";
                break;
            default: state = "unknown";
        }
        return "[Promise " + this._id + ": " + state + "]";
    };
    /**
     * Create a promise that resolves with the same value of this promise, after
     * `ms` milliseconds. The timer will start when the current promise is
     * resolved.
     * If the current promise is rejected, the resulting promise is also
     * rejected, without waiting for the timer.
     *
     * @param ms Number of milliseconds to wait before resolving
     * @return Promise that fulfills `ms` milliseconds after this promise fulfills
     */
    Promise.prototype.delay = function (ms) {
        return this.then(function (value) {
            return new Promise(function (resolve) {
                setTimeout(function () { return resolve(value); }, ms);
            });
        });
    };
    /**
     * Return a promise that resolves to `value` after this promise is
     * fulfilled.
     * Returned promise is rejected if this promise is rejected.
     *
     * Equivalent to `.then(() => value)`.
     *
     * @param value Value or promise for value of returned promise
     * @return Promise resolved to value after this promise fulfills
     */
    Promise.prototype.return = function (value) {
        if (value === undefined) {
            // In TypeScript, we often need to 'force' a promise to become a
            // void promise, so this is a common case. Prevents the closure.
            // (Note: the any cast is just because TS assumes were going to
            // return an R, but we're in fact going to return a void.)
            return this.then(noop);
        }
        return this.then(function () { return value; });
    };
    /**
     * Return a promise that is rejected with `reason` after this promise is
     * fulfilled.
     * If this promise is rejected, returned promise will rejected with that
     * error instead.
     *
     * Equivalent to `.then(() => { throw value; })`.
     *
     * @param reason Error reason to reject returned promise with
     * @return Promise rejected with `reason` after this promise fulfills
     */
    Promise.prototype.throw = function (reason) {
        return this.then(function () { return Promise.reject(reason); });
    };
    Promise.prototype._setSource = function (source) {
        if (!this._trace || !source._trace) {
            return;
        }
        this._trace.setSource(source._trace);
    };
    Promise.prototype._resolve = function (x) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        if (!x) {
            // Shortcut for falsy values, most notably void-Promises
            // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`
            this._fulfill(x);
            return;
        }
        // 2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.
        if (this === x) {
            this._reject(new TypeError("cannot resolve Promise to self"));
            return;
        }
        // 2.3.2: If `x` is a promise, adopt its state
        if (x instanceof Promise) {
            x._setSource(this);
            x._setRejectionHandled(); // we take over responsibility now
            if (x._state === 0 /* Pending */) {
                // 2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.
                this._followPromise(x);
            }
            else if (x._state === 1 /* Fulfilled */) {
                // 2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.
                this._fulfill(x._result);
            }
            else {
                // 2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.
                this._reject(x._result);
            }
            return;
        }
        // 2.3.3: Otherwise, if `x` is an object or function,
        if (typeof x === "object" || typeof x === "function") {
            // 2.3.3.1: Let `then` be `x.then`
            var then = this._tryGetThen(x);
            // 2.3.3.2: If retrieving the property `x.then` results in a thrown
            // exception `e`, reject `promise` with `e` as the reason.
            if (then === getThenError) {
                this._reject(wrapNonError(getThenError.error));
                return;
            }
            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,
            //          first argument `resolvePromise`, and second argument `rejectPromise`
            if (typeof then === "function") {
                this._followThenable(x, then);
                return;
            }
            // 2.3.3.4: If `then` is not a function, fulfill promise with `x`
        }
        // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`
        this._fulfill(x);
    };
    Promise.prototype._tryGetThen = function (x) {
        try {
            // 2.3.3.1: Let `then` be `x.then`
            var then = x.then;
            return then;
        }
        catch (e) {
            // 2.3.3.2: If retrieving the property `x.then` results in a thrown
            // exception `e`, reject `promise` with `e` as the reason.
            getThenError.error = e;
            return getThenError;
        }
    };
    Promise.prototype._fulfill = function (value) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_fulfill(" + typeof value + ")");
        // 2.1.2.2 When fulfilled, a promise must have a value, which must not change.
        this._state = 1 /* Fulfilled */;
        this._result = value;
        this._flush();
    };
    Promise.prototype._reject = function (reason) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_reject(" + reason + ")");
        // 2.1.3.2 When rejected, a promise must have a reason, which must not change.
        this._state = 2 /* Rejected */;
        this._result = reason;
        if (this._trace && this._result instanceof Error && !this._result.trace) {
            var stackTrace_1 = this._trace;
            this._result.trace = stackTrace_1;
            // TODO: Meh, this always accesses '.stack', which is supposed to be expensive
            var originalStack_1 = this._result.stack;
            // Stack may be undefined if e.g. a Stack Overflow occurred
            if (originalStack_1) {
                Object.defineProperty(this._result, "stack", {
                    enumerable: false,
                    get: function () { return originalStack_1 + "\n  from Promise at:\n" + stackTrace_1.inspect(); },
                });
            }
        }
        // Schedule check for possibly unhandled rejections, if not already handled
        if (!(this._flags & 1 /* RejectionHandled */)) {
            async_1.default.enqueueIdle(Promise._unhandledRejectionChecker, this);
        }
        this._flush();
    };
    Promise.prototype._setRejectionHandled = function () {
        if (!(this._flags & 1 /* RejectionHandled */) && (this._flags & 2 /* UnhandledRejectionNotified */)) {
            // The rejection has been declared as PossiblyUnhandledRejection
            // before, so declare it handled again.
            async_1.default.enqueue(Promise._onPossiblyUnhandledRejectionHandledHandler, this);
        }
        this._flags |= 1 /* RejectionHandled */;
        trace && trace(this, "rejectionHandled");
    };
    Promise.prototype._doCheckUnhandledRejection = function () {
        // We get here if this promise is rejected, and wasn't handled at the
        // time it was rejected. Emit a PossiblyUnhandledRejection in case
        // it still isn't handled yet.
        if (!(this._flags & 1 /* RejectionHandled */) && !(this._flags & 2 /* UnhandledRejectionNotified */)) {
            this._flags |= 2 /* UnhandledRejectionNotified */;
            async_1.default.enqueue(Promise._onPossiblyUnhandledRejectionHandler, this);
        }
    };
    Promise.prototype._followPromise = function (slave) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_follow([Promise " + slave._id + "])");
        slave._enqueue(undefined, undefined, this, undefined);
    };
    Promise.prototype._followThenable = function (slave, then) {
        var _this = this;
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_follow([Thenable])");
        var called = false;
        try {
            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,
            //          first argument `resolvePromise`, and second argument `rejectPromise`
            then.call(slave, function (y) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,
                // run `[[Resolve]](promise, y)`
                called = true;
                _this._resolve(y);
            }, function (r) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,
                // reject `promise` with `r`
                called = true;
                _this._reject(wrapNonError(r));
            });
        }
        catch (e) {
            // 2.3.3.3.4: If calling `then` throws an exception `e`,
            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.
            if (!called) {
                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.
                called = true;
                this._reject(wrapNonError(e));
            }
        }
    };
    Promise.prototype._enqueue = function (onFulfilled, onRejected, slave, done) {
        var h = {
            promise: this,
            onFulfilled: onFulfilled,
            onRejected: onRejected,
            slave: slave,
            done: done,
        };
        if (this._state !== 0 /* Pending */) {
            async_1.default.enqueue(Promise._unwrapper, h);
        }
        else {
            if (!this._handlers) {
                this._handlers = [h];
            }
            else {
                var i = this._handlers.length;
                this._handlers[i] = h;
            }
        }
        this._setRejectionHandled();
    };
    /**
     * Schedule any pending .then()/.done() callbacks and follower-promises to
     * be called/resolved.
     * Clears our queue, any callbacks/followers attached after this will be
     * scheduled without going through our handlers queue.
     */
    Promise.prototype._flush = function () {
        if (!this._handlers) {
            return;
        }
        var i = 0;
        var h = this._handlers;
        var l = h.length;
        this._handlers = undefined;
        while (i < l) {
            // Note: we enqueue every single callback/follower separately,
            // because e.g. .done() might throw and we need to ensure we can
            // continue after that. async handles that for us.
            // And because the queue needs to be processed in-order, we can't
            // 'filter' the non-callback operations out either.
            async_1.default.enqueue(Promise._unwrapper, h[i++]);
        }
    };
    /**
     * 'Unwrap' a promise handler, i.e. call a .then()/.done() callback, or
     * resolve a promise that's following us.
     * @param handler The handler being processed
     */
    Promise.prototype._unwrap = function (handler) {
        var callback = this._state === 1 /* Fulfilled */ ? handler.onFulfilled : handler.onRejected;
        if (handler.done) {
            // Unwrap .done() callbacks
            trace && trace(this, "_unwrap()");
            if (typeof callback !== "function") {
                // No callback: if we ended in a rejection, throw it, otherwise
                // all was good.
                if (this._state === 2 /* Rejected */) {
                    Promise._onUnhandledRejectionHandler(this._result, handler.done);
                }
                return;
            }
            util_1.assert(!unwrappingPromise);
            unwrappingPromise = this;
            try {
                var result = callback(this._result);
                if (result) { // skips the common cases like `undefined`
                    // May be a thenable, need to start following it...
                    var p = (result instanceof Promise) ? result : Promise.resolve(result);
                    p.done(); // Ensure it throws as soon as it's rejected
                }
                unwrappingPromise = undefined;
            }
            catch (e) {
                unwrappingPromise = undefined;
                Promise._onUnhandledRejectionHandler(e, handler.done);
            }
            return;
        }
        // Unwrap .then() callbacks, or resolve 'parent' promise
        //
        // Three scenarios are handled here:
        // 1. An onFulfilled callback was registered and promise is fulfilled,
        //    or onRejected callback was registered and promise is rejected
        //    -> callback is a function, slave is the promise that was returned
        //       from the .then() call, so resolve slave with outcome of callback
        // 2. An onFulfilled callback was registered but promise is rejected,
        //    or onRejected callback was registered but promise is fulfilled
        //    -> callback is not a function (typically `undefined`), slave is
        //       promise that was returned from the .then() call, so resolve it
        //       with our own result (thereby 'skipping' the .then())
        // 3. Another promise attached itself on our 'callback queue' to be
        //    resolved when we do (i.e. its fate is determined by us)
        //    -> callbacks will both be undefined, slave is that other promise
        //       that wants to be resolved with our result
        var slave = handler.slave;
        trace && trace(this, "_unwrap(" + slave._id + ")");
        if (typeof callback === "function") {
            // Case 1
            util_1.assert(!unwrappingPromise);
            unwrappingPromise = slave;
            try {
                // 2.2.5 handlers must be called as functions
                slave._resolve(callback(this._result));
            }
            catch (e) {
                slave._reject(wrapNonError(e));
            }
            unwrappingPromise = undefined;
        }
        else {
            // Case 2 and 3
            if (this._state === 1 /* Fulfilled */) {
                slave._fulfill(this._result);
            }
            else {
                slave._reject(this._result);
            }
        }
    };
    /**
     * Create an immediately resolved promise (in case of a 'normal' value), or
     * a promise that 'follows' another `Thenable` (e.g. a Promise from another
     * library).
     *
     * @param value Value (or Thenable for value) for returned promise
     * @return Promise resolved to `value`
     */
    Promise.resolve = function (value) {
        var p = new Promise(internalResolver);
        p._resolve(value);
        return p;
    };
    /**
     * Create an immediately rejected promise.
     *
     * Note: to create a rejected promise of a certain type, use e.g.
     * `Promise.reject<number>(myError)`
     *
     * @param reason Error object to set rejection reason
     * @return Promise resolved to rejection `reason`
     */
    Promise.reject = function (reason) {
        var p = new Promise(internalResolver);
        p._reject(reason);
        return p;
    };
    /**
     * Return a promise for an array of all resolved input promises (or values).
     * If any of the input promises is rejected, the returned promise is
     * rejected with that reason.
     * When passing an empty array, the promises is immediately resolved to an
     * empty array.
     *
     * @param thenables Array of values or promises for them
     * @return promise that resolves with array of all resolved values
     */
    Promise.all = function (thenables) {
        return new Promise(function (resolve, reject) {
            util_1.assert(Array.isArray(thenables), "thenables must be an Array");
            if (thenables.length === 0) {
                resolve([]);
                return;
            }
            var result = new Array(thenables.length);
            var remaining = thenables.length;
            for (var i = 0; i < thenables.length; i++) {
                follow(thenables[i], i);
            }
            function follow(t, index) {
                var slave = t instanceof Promise ? t : Promise.resolve(t);
                slave.done(function (v) {
                    result[index] = v;
                    remaining--;
                    if (remaining === 0) {
                        resolve(result);
                    }
                }, function (reason) { return reject(reason); });
            }
        });
    };
    /**
     * Return a promise that resolves to the fulfillment or rejection of the
     * first input promise that resolves.
     * When passing an empty array, the promise will never resolve.
     *
     * @param thenables Array of values or promises for them
     * @return promise that resolves to first resolved input promise
     */
    Promise.race = function (thenables) {
        return new Promise(function (resolve, reject) {
            util_1.assert(Array.isArray(thenables), "thenables must be an Array");
            for (var _i = 0, thenables_1 = thenables; _i < thenables_1.length; _i++) {
                var t = thenables_1[_i];
                var slave = t instanceof Promise ? t : Promise.resolve(t);
                Promise.resolve(slave).done(resolve, reject);
            }
        });
    };
    /**
     * Create tuple of a promise and its resolve and reject functions.
     *
     * It is generally better (and slightly faster) to use the Promise
     * constructor to create a promise, as that will also catch any exception
     * thrown while running the resolver.
     *
     * A Deferred can be useful in some scenarios though, e.g. when working with
     * timers, protocol request/response pairs, etc.
     *
     * @return Deferred object, containing unresolved promise and its
     *         resolve/reject functions
     */
    Promise.defer = function () {
        var resolve;
        var reject;
        var p = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        return {
            promise: p,
            reject: reject,
            resolve: resolve,
        };
    };
    /**
     * Create a promise that resolves to the given value (or promise for a
     * value) after `ms` milliseconds. The timer will start when the given value
     * is resolved.
     * If the input value is a rejected promise, the resulting promise is also
     * rejected, without waiting for the timer.
     *
     * @param value Value or promise for value to be delayed
     * @param ms Number of milliseconds to wait before resolving
     * @return Promise that fulfills `ms` milliseconds after given (promise for)
     *         value is fulfilled
     */
    Promise.delay = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (arguments[1] === undefined) {
            // delay(ms)
            var ms_1 = arguments[0];
            return new Promise(function (resolve) {
                setTimeout(resolve, ms_1);
            });
        }
        // delay(value, ms)
        return Promise.resolve(arguments[0]).delay(arguments[1]);
    };
    /**
     * Register a callback to be called whenever a rejected Promise reaches a `.done()` call
     * without `rejectHandler` argument, or either of the `.done()` callbacks itself
     * throws/rejects.
     *
     * This is similar to Node's `unhandledException` event, in that it is guaranteed to be
     * an error, because the programmer explicitly marked the chain with `.done()`.
     *
     * Node also has an `unhandledRejection` event, which is actually closer to ts-promise's
     * `onPossiblyUnhandledRejection` handler.
     *
     * The default handler will throw an `UnhandledRejection` error, which contains the
     * original reason of the rejection.
     * In Node, if you don't have an `unhandledException` event handler, that will cause your
     * program to terminate after printing the error.
     * When overriding the default handler, it is recommended to keep a similar behavior,
     * as your program is likely in an unknown state.
     *
     * @see onPossiblyUnhandledRejection
     *
     * @param handler Callback called with the rejection reason (typically an `Error`), and a
     *                `Trace` to the `.done()` call that terminated the chain. Call e.g.
     *                `trace.inspect()` to get the full trace.
     *                If `true` is given, the default handler is installed.
     *                If `false` is given, a no-op handler is installed.
     */
    Promise.onUnhandledRejection = function (handler) {
        if (handler === true) {
            Promise._onUnhandledRejectionHandler = rejections_1.defaultUnhandledRejectionHandler;
        }
        else if (handler === false) {
            Promise._onUnhandledRejectionHandler = noop;
        }
        else if (typeof handler !== "function") {
            throw new TypeError("invalid handler: boolean or function expected");
        }
        else {
            Promise._onUnhandledRejectionHandler = handler;
        }
    };
    /**
     * Register a callback to be called whenever a rejected Promise is not handled
     * by any `.catch()` (or second argument to `.then()`) at the end of one turn of the
     * event loop.
     *
     * Note that such a rejected promise may be handled later (by e.g. calling `.catch(() => {})`
     * on it). In that case, a subsequent call to an `onPossiblyUnhandledRejectionHandled` callback
     * will be made.
     *
     * This mechanism is equivalent to Node's `unhandledRejection` event.
     *
     * The default handler will:
     * - emit Node's `unhandledRejection` event if present, or
     * - emit an `unhandledrejection` (note small R) `PromiseRejectionEvent` on `window` or `self` if present, or
     * - log the rejection using `console.warn()`.
     *
     * Note: when attaching an `unhandledrejection` handler in the browser, make sure to
     * call `event.preventDefault()` to prevent ts-promise's default fallback logging.
     *
     * @see onUnhandledRejection
     * @see onPossiblyUnhandledRejectionHandled
     *
     * @param handler Callback called with the (so-far) unhandled rejected promise.
     *                If `true` is given, the default handler is installed.
     *                If `false` is given, a no-op handler is installed.
     */
    Promise.onPossiblyUnhandledRejection = function (handler) {
        if (handler === true) {
            Promise._onPossiblyUnhandledRejectionHandler = rejections_1.defaultPossiblyUnhandledRejectionHandler;
        }
        else if (handler === false) {
            Promise._onPossiblyUnhandledRejectionHandler = noop;
        }
        else if (typeof handler !== "function") {
            throw new TypeError("invalid handler: boolean or function expected");
        }
        else {
            Promise._onPossiblyUnhandledRejectionHandler = handler;
        }
    };
    /**
     * Register a callback to be called whenever a rejected promise previously reported as
     * 'possibly unhandled', now becomes handled.
     *
     * This mechanism is equivalent to Node's `rejectionHandled` event.
     *
     * The default handler will emit Node's `rejectionHandled` event if present, or emit a
     * `rejectionhandled` (note small R) event on `window` (or `self`) if present.
     *
     * @see onPossiblyUnhandledRejection
     *
     * @param handler Callback called with a rejected promise that was previously reported as
     *                'possibly unhandled'.
     *                If `true` is given, the default handler is installed.
     *                If `false` is given, a no-op handler is installed.
     */
    Promise.onPossiblyUnhandledRejectionHandled = function (handler) {
        if (handler === true) {
            Promise._onPossiblyUnhandledRejectionHandledHandler = rejections_1.defaultPossiblyUnhandledRejectionHandledHandler;
        }
        else if (handler === false) {
            Promise._onPossiblyUnhandledRejectionHandledHandler = noop;
        }
        else if (typeof handler !== "function") {
            throw new TypeError("invalid handler: boolean or function expected");
        }
        else {
            Promise._onPossiblyUnhandledRejectionHandledHandler = handler;
        }
    };
    /**
     * Enable or disable long stack trace tracking on promises.
     *
     * This allows tracing a promise chain through the various asynchronous
     * actions in a program. For example, when a promise is rejected, the last
     * few locations of any preceding promises are included in the error's stack
     * trace.
     *
     * Note: it is possible to enable/disable long tracing at runtime.
     *
     * When chaining off of a promise that was created while tracing was enabled
     * (e.g. through `.then()`), all children will also have long traces, even
     * when tracing is turned off. This allows to trace just some promise paths.
     *
     * Tracing is disabled by default as it incurs a memory and performance
     * overhead, although it's still faster with tracing than some major
     * promise libraries without tracing, so don't worry too much about it.
     *
     * @param enable Set to true to enable long traces, false to disable
     */
    Promise.setLongTraces = function (enable) {
        longTraces = enable;
    };
    /**
     * Set trace function that is called for internal state changes of a
     * promise.
     * Call with `undefined` or `null` to disable such tracing (this is the
     * default).
     *
     * @param tracer Callback called for various stages during lifetime of a promise
     */
    // tslint:disable-next-line:no-null-keyword
    Promise.setTracer = function (tracer) {
        if (typeof tracer === "function") {
            trace = tracer;
        }
        else {
            trace = undefined;
        }
    };
    /**
     * Recursively flush the async callback queue until all `.then()` and
     * `.done()` callbacks for fulfilled and rejected Promises have been called.
     * Useful in e.g. unit tests to advance program state to the next 'tick'.
     *
     * Note that if e.g. `.done()` encounters a rejected promise, `flush()` will
     * immediately throw an error (e.g. `UnhandledRejectionError`).
     * It is safe to call `flush()` again afterwards, but it will also be called
     * automatically by the async queue on the next 'real' tick.
     *
     * It is an error to call `flush()` while it is already running (e.g. from
     * a `.then()` callback).
     */
    Promise.flush = function () {
        async_1.default.flush();
    };
    /**
     * Helper for unwrapping promise handler.
     * It's not a closure so it's cheap to schedule, and because it directly
     * calls the _unwrap() method on a promise, it's (way) faster than having to
     * use e.g. .call().
     * @param handler The handler being processed
     */
    Promise._unwrapper = function (handler) {
        handler.promise._unwrap(handler);
    };
    /**
     * Helper for checking for possibly unhandled rejections.
     * @param promise The Promise to check
     */
    Promise._unhandledRejectionChecker = function (promise) {
        promise._doCheckUnhandledRejection();
    };
    return Promise;
}());
exports.Promise = Promise;
// Install default rejection handlers
Promise.onUnhandledRejection(true);
Promise.onPossiblyUnhandledRejection(true);
Promise.onPossiblyUnhandledRejectionHandled(true);
exports.default = Promise;

},{"./Trace":4,"./async":5,"./rejections":8,"./util":9}],3:[function(require,module,exports){
"use strict";
/**
 * Helper class for capturing stack traces.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO:
// - test/make it work in non-V8
// - parse stacks into platform-independent object-arrays
var hasStacks = (typeof Error.captureStackTrace === "function");
var Stack = /** @class */ (function () {
    function Stack(ignoreUntil) {
        if (ignoreUntil === void 0) { ignoreUntil = Stack; }
        /* istanbul ignore else */ // TODO: remove when testing for non-V8
        if (hasStacks) {
            Error.captureStackTrace(this, ignoreUntil);
        }
        else {
            this.stack = "dummy\n<no trace>";
        }
    }
    Stack.prototype.inspect = function () {
        var lines = this.stack.split("\n");
        lines.shift(); // Strip the "[object Object]" line
        return lines.join("\n");
    };
    return Stack;
}());
exports.default = Stack;

},{}],4:[function(require,module,exports){
"use strict";
/**
 * Helper class for capturing stack traces.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO:
// - test/make it work in non-V8
var Stack_1 = require("./Stack");
/**
 * Stack trace container with optional source traces.
 *
 * Typically used for capturing traces across asynchronous calls (e.g.
 * with Promises or Events).
 */
var Trace = /** @class */ (function () {
    function Trace(ignoreUntil) {
        if (ignoreUntil === void 0) { ignoreUntil = Trace; }
        this.stack = new Stack_1.default(ignoreUntil);
    }
    /**
     * Assign another Trace as the source of this Trace.
     *
     * Note: the stack of `source` is copied to this Trace, in order to allow
     * truncating the trace length to `Trace.traceLimit` to prevent memory
     * exhaustion on e.g. recursive traces.
     *
     * @param source Trace to use as source.
     */
    Trace.prototype.setSource = function (source) {
        if (!source.sources) {
            this.sources = [source.stack];
        }
        else {
            this.sources = source.sources.concat(source.stack);
            if (this.sources.length > Trace.traceLimit) {
                this.sources = this.sources.slice(0, Trace.traceLimit);
            }
        }
    };
    Trace.prototype.inspect = function () {
        var result = this.stack.inspect();
        if (this.sources) {
            for (var i = this.sources.length - 1; i >= 0; i--) {
                result += "\n  from previous:\n" + this.sources[i].inspect();
            }
        }
        return result;
    };
    Trace.traceLimit = 10;
    return Trace;
}());
exports.default = Trace;

},{"./Stack":3}],5:[function(require,module,exports){
"use strict";
/**
 * Call queue for executing callbacks asynchronously.
 *
 * Prevents releasing Zalgo.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var CallQueue = /** @class */ (function () {
    function CallQueue() {
        this.length = 0;
        // Basically twice the number of simultaneously resolving promises
        this._max = 1000;
        this._first = 0;
    }
    /**
     * Push a new callback to the queue.
     * @return true when the queue still has space, false if it's now 'full'
     */
    CallQueue.prototype.push = function (callback, arg) {
        this[this.length++] = callback;
        this[this.length++] = arg;
        return this.length < this._max;
    };
    /**
     * Flush all callbacks in this queue.
     * Note that it is 'ok' for callbacks to throw an error;
     * the next call to flush() will flush the remainder of the queue.
     * When this function returns, the queue will be 'reset' to its beginning.
     */
    CallQueue.prototype.flush = function () {
        while (this._first < this.length) {
            var callback = this[this._first];
            var arg = this[this._first + 1];
            this[this._first] = this[this._first + 1] = undefined;
            this._first += 2;
            callback(arg);
        }
        this.length = 0;
        this._first = 0;
    };
    CallQueue.prototype.empty = function () {
        return this._first === this.length;
    };
    return CallQueue;
}());
var Ring = /** @class */ (function () {
    function Ring(pool) {
        /**
         * Ring of queues.
         * Guaranteed to always contain at least one queue.
         */
        this._ring = [new CallQueue()];
        /**
         * Queue to put new callbacks in, i.e. the last queue in the ring.
         * If `undefined`, a new queue will be obtained and added to ring on next enqueue.
         */
        this._current = this._ring[0];
        this._pool = pool;
    }
    Ring.prototype.enqueue = function (callback, arg) {
        // Make sure this._current points to a queue: obtain one
        // from pool or create a new one if necessary.
        if (!this._current) {
            this._current = this._pool.pop();
            if (!this._current) {
                this._current = new CallQueue();
            }
            this._ring.push(this._current);
        }
        // Add callback to queue
        if (!this._current.push(callback, arg)) {
            // Queue full, load a new one next time
            this._current = undefined;
        }
    };
    /**
     * Call all callbacks in all queues in this ring, until it is empty.
     * Note: it is 'OK' for a callback to throw an error; ring/queue state
     * will remain valid and remaining items will be flushed on next call
     * to `flush()`.
     */
    Ring.prototype.flush = function () {
        while (true) {
            // Ring is guaranteed to have at least one queue (even though
            // queue might be empty when flush() is e.g. called manually).
            this._ring[0].flush();
            // If this is the last queue in the ring, we're done
            if (this._ring.length === 1) {
                break;
            }
            // Shift the now empty ring into pool.
            // Queue at index 0 is empty, and ring length >= 2.
            // So, this._current is guaranteed to point to something 'later'
            // than queue at index 0, and we can safely move index 0 to the
            // pool.
            this._pool.push(this._ring.shift());
        }
        // Ring is now guaranteed to contain only a single, empty queue, so we
        // could move it to the pool.
        // However, because it's the last item remaining, better to simply
        // leave it in the ring, saves unnecessary re-move on next enqueue.
        // Also, make sure that new items will be loaded into that queue.
        this._current = this._ring[0];
    };
    /**
     * Return true if no callbacks are enqueued in this ring.
     */
    Ring.prototype.empty = function () {
        return this._ring.length === 1 && this._ring[0].empty();
    };
    return Ring;
}());
function defaultScheduler(callback) {
    // Note: we explicitly re-check types and call it here (instead of
    // e.g. assigning it to a variable once at startup), to allow
    // setImmediate / setTimeout to be replaced by mocked ones
    // (e.g. Sinon's useFakeTimers())
    if (typeof setImmediate === "function") {
        setImmediate(callback);
    }
    else {
        setTimeout(callback, 0);
    }
}
var Async = /** @class */ (function () {
    function Async() {
        var _this = this;
        this._pool = [];
        this._mainRing = new Ring(this._pool);
        this._idleRing = new Ring(this._pool);
        this._flushing = false;
        this._scheduled = false;
        this._scheduler = undefined;
        this._flusher = function () { return _this._scheduledFlush(); };
    }
    /**
     * Configure alternative scheduler to use.
     * The scheduler function will be called with a flusher, which needs to be
     * executed to flush the queue. Note: the flusher may throw an
     * exception, if any of the callbacks on the queue throws one.
     * This will result in another flush to be scheduled before returning.
     *
     * Call with `undefined` to reset the scheduler to the default (setImmediate).
     *
     * Example usage (this is basically the default):
     *   setScheduler((flusher) => setImmediate(flusher));
     * Note: this is slightly different from just setScheduler(setImmediate), in that
     * the former allows overriding setImmediate in e.g. unit tests.
     */
    Async.prototype.setScheduler = function (scheduler) {
        /* tslint:disable:no-null-keyword */ // 'old' API told you to use `null` instead of `undefined`
        util_1.assert(scheduler === undefined || scheduler === null || typeof scheduler === "function");
        /* tslint:enable:no-null-keyword */
        this._scheduler = scheduler;
    };
    Async.prototype.enqueue = function (callback, arg) {
        if (!this._flushing && !this._scheduled) {
            this._schedule();
        }
        this._mainRing.enqueue(callback, arg);
    };
    Async.prototype.enqueueIdle = function (callback, arg) {
        if (!this._flushing && !this._scheduled) {
            this._schedule();
        }
        this._idleRing.enqueue(callback, arg);
    };
    /**
     * Flush callback queues.
     * First, the 'normal' callback queues are flushed until they are empty (i.e.
     * new callbacks that are added while executing will also be processed).
     * Then, the 'idle' queues are flushed (also until they are empty).
     * Flushing repeats until no more items are enqueued in normal or idle queues.
     * It is an error to call flush from within an enqueued callback.
     */
    Async.prototype.flush = function () {
        util_1.assert(!this._flushing, "cannot recursively flush");
        this._flushing = true;
        try {
            while (true) {
                this._mainRing.flush();
                if (this._idleRing.empty()) {
                    // Both rings now empty: done
                    break;
                }
                // Main ring empty, idle ring not empty.
                // Start flushing idle ring, making sure it is completely
                // processed before processing new 'normal' callbacks (even
                // if it is interrupted by a thrown error in one of them).
                // Also, make sure that any new normal callbacks are going
                // to be processed before any new idle callbacks.
                var emptyRing = this._mainRing;
                this._mainRing = this._idleRing;
                this._idleRing = emptyRing;
            }
        }
        finally {
            this._flushing = false;
            // If one of the callbacks in the queue throws an exception,
            // (e.g. when Promise#done() detects a rejection) make sure to
            // reschedule the remainder of the queue(s) for another iteration.
            // This approach has the advantage of immediately allowing to stop
            // the program in e.g. NodeJS, but also allows to continue running
            // correctly in a browser.
            // Note: we may be called explicitly, even though we were also
            // already scheduled, before.
            if ((!this._mainRing.empty() || !this._idleRing.empty()) && !this._scheduled) {
                this._schedule();
            }
        }
    };
    Async.prototype._schedule = function () {
        util_1.assert(!this._scheduled);
        var scheduler = this._scheduler || defaultScheduler;
        // Call scheduler without a `this`
        scheduler(this._flusher);
        this._scheduled = true;
    };
    Async.prototype._scheduledFlush = function () {
        // Indicate that this 'iteration' of the flush is complete.
        this._scheduled = false;
        this.flush();
    };
    return Async;
}());
exports.Async = Async;
exports.async = new Async();
exports.default = exports.async;

},{"./util":9}],6:[function(require,module,exports){
"use strict";
/**
 * TS-Promise - fast, robust, type-safe promises
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Promise_1 = require("./Promise");
exports.default = Promise_1.default;
exports.Promise = Promise_1.Promise;
var Trace_1 = require("./Trace");
exports.Trace = Trace_1.default;
var rejections_1 = require("./rejections");
exports.UnhandledRejection = rejections_1.UnhandledRejection;
exports.PossiblyUnhandledRejection = rejections_1.PossiblyUnhandledRejection;
var rejections_2 = require("./rejections"); // backwards compatibility
exports.UnhandledRejectionError = rejections_2.UnhandledRejection;
var polyfill_1 = require("./polyfill");
exports.polyfill = polyfill_1.default;
// Temporary, should be moved to its own package some day
var BaseError_1 = require("./BaseError");
exports.BaseError = BaseError_1.default;

},{"./BaseError":1,"./Promise":2,"./Trace":4,"./polyfill":7,"./rejections":8}],7:[function(require,module,exports){
"use strict";
/**
 * Polyfill implementation.
 *
 * Copyright (C) 2016 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Promise_1 = require("./Promise");
var util_1 = require("./util");
/**
 * Polyfill global `Promise` instance with ts-promise version.
 * By default, it will only install a ts-promise version if no other
 * implementation is present. Use `force = true` to unconditionally replace the
 * promise implementation.
 *
 * Warning: in general, it's not really recommended to use polyfills, because
 * other libraries may e.g. use the fact that certain platform features are
 * absent to create a 'fingerprint' of a platform, and it may conflict with
 * other libraries that are trying to do the same thing.
 * If you're writing your own library, it's much better to simply directly
 * require/import ts-promise, and use its class directly.
 * However, if you're the 'end-user' (i.e. application, not a library), it may
 * be a viable solution to make Promises available on platforms that otherwise
 * don't have them.
 *
 * @param  {boolean}  force (Optional, default false) Forcibly overwrite existing Promise implementation with
 *                          ts-promise version.
 * @return {boolean}        Returns true when global Promise is (now) a ts-promise (or derived class), false otherwise.
 */
function polyfill(force) {
    if (force === void 0) { force = false; }
    // Get reference to globals (`global`, `window`, etc.)
    var global = util_1.getGlobal();
    if (!global) {
        return false;
    }
    if (force || typeof global.Promise !== "function") {
        global.Promise = Promise_1.Promise;
        return true;
    }
    return global.Promise instanceof Promise_1.Promise;
}
exports.default = polyfill;

},{"./Promise":2,"./util":9}],8:[function(require,module,exports){
"use strict";
/**
 * Definitely- and possibly-unhandled rejection handling.
 *
 * Copyright (C) 2017 Martin Poelstra
 * License: MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseError_1 = require("./BaseError");
var util_1 = require("./util");
/**
 * Base class for errors thrown when a (possibly) rejected promise is detected.
 */
var BaseUnhandledRejection = /** @class */ (function (_super) {
    __extends(BaseUnhandledRejection, _super);
    function BaseUnhandledRejection(name, message, reason) {
        var _this = _super.call(this, name, message + ": " + reason) /* istanbul ignore next (TS emitted code) */ || this;
        _this.reason = reason;
        // In case we have a reason, and it has a stack: use it instead of our
        // own stack, as it's more helpful to see where the original error was
        // thrown, than where it was thrown inside the promise lib.
        // In case we don't have a stack, explicitly state so, to not let people
        // chase a problem in the promise lib that isn't there...
        var stack = _this.reason && typeof _this.reason === "object" && _this.reason.stack;
        if (typeof stack !== "string") {
            stack = String(_this.reason);
        }
        _this.stack = _this.name + ": " + stack;
        return _this;
    }
    return BaseUnhandledRejection;
}(BaseError_1.default));
exports.BaseUnhandledRejection = BaseUnhandledRejection;
/**
 * Thrown when a rejected promise is explicitly terminated with `.done()`.
 */
var UnhandledRejection = /** @class */ (function (_super) {
    __extends(UnhandledRejection, _super);
    function UnhandledRejection(reason, trace) {
        var _this = _super.call(this, "UnhandledRejection", "unhandled rejection", reason) /* istanbul ignore next (TS emitted code) */ || this;
        // TODO: Find a better way to merge the location of `.done()` in the
        // trace, because nobody will look for this property...
        _this.trace = trace;
        return _this;
    }
    return UnhandledRejection;
}(BaseUnhandledRejection));
exports.UnhandledRejection = UnhandledRejection;
/**
 * Emitted when a rejected promise isn't handled.
 * @see Promise.onPossiblyUnhandledRejection
 */
var PossiblyUnhandledRejection = /** @class */ (function (_super) {
    __extends(PossiblyUnhandledRejection, _super);
    function PossiblyUnhandledRejection(promise) {
        var _this = _super.call(this, "PossiblyUnhandledRejection", "possibly unhandled rejection", promise.reason()) /* istanbul ignore next (TS emitted code) */ || this;
        _this.promise = promise;
        return _this;
    }
    return PossiblyUnhandledRejection;
}(BaseUnhandledRejection));
exports.PossiblyUnhandledRejection = PossiblyUnhandledRejection;
/**
 * Emit PromiseRejectionEvent (in browser environment).
 * Dispatches the event to all registered handlers, e.g.
 * - window.onunhandledrejection / window.onrejectionhandled
 * - window.addEventListener("unhandledrejection", (event) => { ... }), etc
 * Uses self in case of WebWorker.
 *
 * @param type Either "unhandledrejection" or "rejectionhandled"
 * @param reason Value used to reject promise
 * @param promise ts-promise instance
 * @return true when event was 'handled' (i.e. someone called preventDefault() on it), false otherwise
 */
function emitRejectionEvent(type, reason, promise) {
    // Browsers do a native Promise.resolve() on the promise given in PromiseRejectEvent,
    // which causes an unhandled rejection error due to that native promise not being handled,
    // and prevents the user's unhandled rejection handler from accessing the actual
    // ts-promise Promise. This would make the handled rejection handler useless, because that
    // gets another native promise.
    // So, prevent the unhandled rejection when constructing the event, then override the
    // property to return the 'real' promise.
    // MDN says it isn't cancelable, but both Chrome and Firefox do have it cancelable.
    var event = new PromiseRejectionEvent(type, {
        cancelable: true,
        promise: true,
        reason: reason,
    });
    Object.defineProperty(event, "promise", {
        value: promise,
    });
    var global = util_1.getGlobal();
    if (global.dispatchEvent && !global.dispatchEvent(event)) {
        // Someone called preventDefault()
        return true;
    }
    return false;
}
/**
 * Default handler for an`UnhandledRejection` error, which contains the
 * original reason of the rejection.
 * In Node, if you don't have an `unhandledException` event handler, that will cause your
 * program to terminate after printing the error.
 * When overriding the default handler, it is recommended to keep a similar behavior,
 * as your program is likely in an unknown state.
 */
function defaultUnhandledRejectionHandler(reason, doneTrace) {
    var unhandledRejection = new UnhandledRejection(reason, doneTrace);
    // Leave the comment after the throw: may show up in source line in node
    throw unhandledRejection; // Unhandled rejection caught by .done()
}
exports.defaultUnhandledRejectionHandler = defaultUnhandledRejectionHandler;
/**
 * Default handler for possibly unhandled rejection. It will:
 * - emit Node's `unhandledRejection` event if present, or
 * - emit an `unhandledrejection` (note small R) `PromiseRejectionEvent` on `window` or `self` if present, or
 * - log the rejection using `console.warn()`.
 *
 * Note: when attaching an `unhandledrejection` handler in the browser, make sure to
 * call `event.preventDefault()` to prevent ts-promise's default fallback logging.
 */
function defaultPossiblyUnhandledRejectionHandler(promise) {
    var log = true;
    // First try to emit Node event
    if (typeof process !== "undefined" && typeof process.emit === "function") {
        if (process.emit("unhandledRejection", promise.reason(), promise)) {
            // A handler was called
            log = false;
        }
    }
    else if (typeof PromiseRejectionEvent === "function") {
        // Then fire a browser event if supported by the browser
        if (emitRejectionEvent("unhandledrejection", promise.reason(), promise)) {
            log = false;
        }
    }
    // Fallback to log to console
    if (log) {
        var possiblyUnhandledRejection = new PossiblyUnhandledRejection(promise);
        // tslint:disable-next-line:no-console
        console.warn(possiblyUnhandledRejection.stack);
    }
}
exports.defaultPossiblyUnhandledRejectionHandler = defaultPossiblyUnhandledRejectionHandler;
/**
 * Default handler for handled rejections.
 * It will emit Node's `rejectionHandled` event if present, or emit a
 * `rejectionhandled` (note small R) event on `window` (or `self`) if present.
 */
function defaultPossiblyUnhandledRejectionHandledHandler(promise) {
    // First try to emit Node event
    if (typeof process !== "undefined" && typeof process.emit === "function") {
        process.emit("rejectionHandled", promise);
    }
    else if (typeof PromiseRejectionEvent === "function") {
        // Then fire a browser event if supported by the browser
        emitRejectionEvent("rejectionhandled", promise.reason(), promise);
    }
}
exports.defaultPossiblyUnhandledRejectionHandledHandler = defaultPossiblyUnhandledRejectionHandledHandler;

},{"./BaseError":1,"./util":9}],9:[function(require,module,exports){
"use strict";
/**
 * Helper utilities.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Throw an Error when given condition is false.
 *
 * @param {any}    condition Condition, no-op when truthy, error thrown when falsy
 * @param {string} msg       Optional text to include in error message
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg ? "assertion failed: " + msg : "assertion failed");
    }
}
exports.assert = assert;
/**
 * Return reference to the global object (if possible).
 *
 * @return {any} Reference to the global object (e.g. `window`, `global`, etc.),
 *               or `undefined` if it could not be determined.
 */
function getGlobal() {
    if (typeof self !== "undefined") { // WebWorkers
        return self;
    }
    if (typeof window !== "undefined") { // Browsers
        return window;
    }
    if (typeof global !== "undefined") { // Serverside (Node)
        return global;
    }
    // Otherwise, try to use `this`.
    // We use eval-like behavior, because it will not inherit our "use strict",
    // see http://stackoverflow.com/questions/3277182/how-to-get-the-global-object-in-javascript
    var g;
    try {
        g = new Function("return this")();
    }
    catch (e) {
        // Content Security Policy might not allow the eval()-evilness above,
        // so just ignore then...
    }
    return g;
}
exports.getGlobal = getGlobal;

},{}]},{},[6])(6)
});
